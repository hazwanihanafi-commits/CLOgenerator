from flask import Flask, render_template, request, jsonify, send_file, redirect, url_for
import pandas as pd, os
from datetime import datetime
from openpyxl import load_workbook
from io import BytesIO

app = Flask(__name__, template_folder="templates")
WORKBOOK_PATH = os.path.join(os.getcwd(), "SCLOG.xlsx")

PROFILE_SHEET_MAP = {
    "": "Mapping",  # default
    "health": "Mapping_health",
    "sc": "Mapping_sc",
    "eng": "Mapping_eng",
    "socs": "Mapping_socs",
    "edu": "Mapping_edu",
    "bus": "Mapping_bus",
    "arts": "Mapping_arts",
}

# ---------- helpers ----------
def load_sheet_df(sheet):
    try:
        return pd.read_excel(WORKBOOK_PATH, sheet_name=sheet, engine="openpyxl")
    except Exception:
        return pd.DataFrame()

def get_mapping_df(profile: str | None):
    sheet = PROFILE_SHEET_MAP.get((profile or "").strip().lower(), "Mapping")
    df = load_sheet_df(sheet)
    if df.empty and sheet != "Mapping":
        df = load_sheet_df("Mapping")
    if df.empty:
        return pd.DataFrame()
    df.columns = [str(c).strip() for c in df.columns]
    return df

def get_plo_details(plo: str, profile: str | None):
    df = get_mapping_df(profile)
    if df.empty:
        return None
    key = df.columns[0]
    mask = df[key].astype(str).str.strip().str.upper() == str(plo).strip().upper()
    if not mask.any():
        return None
    row = df[mask].iloc[0]
    cols = {c.lower(): c for c in df.columns}
    return {
        "PLO": row[key],
        "SC_Code": row.get(cols.get("sc code"), ""),
        "SC_Desc": row.get(cols.get("sc description"), ""),
        "VBE": row.get(cols.get("vbe"), ""),
        "Domain": row.get(cols.get("domain"), ""),
    }

def get_criterion_condition(domain, bloom):
    df = load_sheet_df("Criterion")
    if df.empty: return "", ""
    df.columns = [str(c).strip() for c in df.columns]
    dom_col  = next((c for c in df.columns if "domain" in c.lower()), df.columns[0])
    blo_col  = next((c for c in df.columns if "bloom"  in c.lower()), df.columns[1])
    crit_col = next((c for c in df.columns if "criterion" in c.lower()), df.columns[2])
    cond_col = next((c for c in df.columns if "condition" in c.lower()), df.columns[3])
    m = (df[dom_col].astype(str).str.lower()==str(domain).lower()) & \
        (df[blo_col].astype(str).str.lower()==str(bloom).lower())
    if not m.any(): return "", ""
    r = df[m].iloc[0]
    return str(r.get(crit_col,"")), str(r.get(cond_col,""))

def get_default_condition(domain):
    return {
        "cognitive":   "in relevant disciplinary contexts",
        "affective":   "in authentic academic or professional settings",
        "psychomotor": "under supervised practical conditions",
    }.get(str(domain).strip().lower(), "")

def get_assessment_and_evidence(bloom, domain):
    sheet = "Assess_Affective_Psychomotor" if str(domain).lower() in ("affective","psychomotor") else "Bloom_Assessments"
    df = load_sheet_df(sheet)
    if df.empty: return "", ""
    df.columns = [str(c).strip() for c in df.columns]
    blo_col, as_col, ev_col = df.columns[:3]
    m = df[blo_col].astype(str).str.strip().str.lower()==str(bloom).strip().lower()
    if not m.any(): return "", ""
    r = df[m].iloc[0]
    return str(r.get(as_col,"")), str(r.get(ev_col,""))

def construct_clo_sentence(verb, content, sc_desc, condition, criterion, vbe):
    # Order: Verb + Content + SC Desc + Condition + Criterion + VBE
    parts = []
    if verb:    parts.append(verb.strip().lower())
    if content: parts.append(content.strip())
    if sc_desc: parts.append(f"using {sc_desc.strip().lower()}")
    if condition:
        cond = condition.strip()
        if not cond.lower().startswith(("when","during","in","under","based")):
            cond = "when " + cond
        parts.append(cond)
    if criterion: parts.append(criterion.strip())
    if vbe:       parts.append(f"guided by {vbe.strip().lower()}")
    sent = " ".join(parts).strip()
    if sent: sent = sent[0].upper()+sent[1:]
    if not sent.endswith("."): sent += "."
    return sent

def read_clo_table():
    try:
        return pd.read_excel(WORKBOOK_PATH, sheet_name="CLO_Table", engine="openpyxl")
    except Exception:
        return pd.DataFrame()

def write_clo_table(df):
    try:
        book = load_workbook(WORKBOOK_PATH)
    except Exception:
        # create workbook if not exists
        with pd.ExcelWriter(WORKBOOK_PATH, engine="openpyxl") as w:
            pd.DataFrame().to_excel(w, sheet_name="INIT", index=False)
        book = load_workbook(WORKBOOK_PATH)
    if "CLO_Table" in book.sheetnames:
        del book["CLO_Table"]
    with pd.ExcelWriter(WORKBOOK_PATH, engine="openpyxl", mode="a") as w:
        w._book = book
        df.to_excel(w, sheet_name="CLO_Table", index=False)

# ---------- routes ----------
@app.route("/")
def index():
    profile = request.args.get("profile","").strip().lower()
    dfm = get_mapping_df(profile)
    plos = dfm[dfm.columns[0]].dropna().astype(str).tolist() if not dfm.empty else []
    df_ct = read_clo_table()
    table_html = df_ct.to_html(classes="table table-striped table-sm", index=False) if not df_ct.empty else "<p>No CLO records yet.</p>"
    return render_template("generator.html", plos=plos, table_html=table_html, profile=profile)

@app.route("/generate", methods=["POST"])
def generate():
    profile = (request.args.get("profile") or request.form.get("profile") or "").strip().lower()
    plo     = request.form.get("plo")
    bloom   = request.form.get("bloom")
    verb    = request.form.get("verb")
    content = request.form.get("content")
    course  = request.form.get("course")
    cw      = request.form.get("cw")

    details = get_plo_details(plo, profile)
    if not details:
        return jsonify({"error":"PLO not found"}), 400

    domain = details["Domain"]
    criterion, condition = get_criterion_condition(domain, bloom)
    if not condition: condition = get_default_condition(domain)
    assessment, evidence = get_assessment_and_evidence(bloom, domain)

    clo = construct_clo_sentence(verb, content, details["SC_Desc"], condition, criterion, details["VBE"])

    df = read_clo_table()
    new_row = {
        "ID": len(df)+1 if not df.empty else 1,
        "Time": datetime.now().strftime("%Y-%m-%d %H:%M"),
        "Course": course, "PLO": plo, "Bloom": bloom,
        "FullCLO": clo,
        "Mapping (SC + VBE)": f"{details['SC_Code']} — {details['VBE']}",
        "Assessment Methods": assessment,
        "Evidence of Assessment": evidence,
        "Coursework Assessment Percentage (%)": cw,
        "Profile": profile
    }
    df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)
    write_clo_table(df)

    return jsonify({"clo": clo, "assessment": assessment, "evidence": evidence})

# dynamic APIs
@app.route("/api/debug_plo/<plo>")
def api_debug_plo(plo):
    profile = request.args.get("profile","").strip().lower()
    d = get_plo_details(plo, profile)
    return jsonify({"plo":plo, "details": d or {}, "exists": bool(d)})

@app.route("/api/get_blooms/<plo>")
def api_get_blooms(plo):
    profile = request.args.get("profile","").strip().lower()
    d = get_plo_details(plo, profile)
    if not d: return jsonify([])
    sheet = {"cognitive":"Bloom_Cognitive","affective":"Bloom_Affective","psychomotor":"Bloom_Psychomotor"}.get(str(d["Domain"]).lower())
    df = load_sheet_df(sheet)
    if df.empty: return jsonify([])
    return jsonify(df.iloc[:,0].dropna().astype(str).str.strip().tolist())

@app.route("/api/get_verbs/<plo>/<bloom>")
def api_get_verbs(plo, bloom):
    profile = request.args.get("profile","").strip().lower()
    d = get_plo_details(plo, profile)
    if not d: return jsonify([])
    sheet = {"cognitive":"Bloom_Cognitive","affective":"Bloom_Affective","psychomotor":"Bloom_Psychomotor"}.get(str(d["Domain"]).lower())
    df = load_sheet_df(sheet)
    if df.empty: return jsonify([])
    m = df.iloc[:,0].astype(str).str.strip().str.lower()==str(bloom).strip().lower()
    if not m.any(): return jsonify([])
    raw = str(df.loc[m].iloc[0,1])
    return jsonify([v.strip() for v in raw.split(",") if v.strip()])

@app.route("/api/get_meta/<plo>/<bloom>")
def api_get_meta(plo, bloom):
    profile = request.args.get("profile","").strip().lower()
    d = get_plo_details(plo, profile)
    if not d: return jsonify({})
    domain = d["Domain"]
    crit, cond = get_criterion_condition(domain, bloom)
    if not cond: cond = get_default_condition(domain)
    assess, evid = get_assessment_and_evidence(bloom, domain)
    return jsonify({
        "sc_code": d["SC_Code"],
        "sc_desc": d["SC_Desc"],
        "vbe": d["VBE"],
        "domain": domain,
        "criterion": crit,
        "condition": cond,
        "assessment": assess,
        "evidence": evid
    })

@app.route("/reset_table")
def reset_table():
    df_empty = pd.DataFrame(columns=[
        "ID","Time","Course","PLO","Bloom","FullCLO",
        "Mapping (SC + VBE)","Assessment Methods","Evidence of Assessment",
        "Coursework Assessment Percentage (%)","Profile"
    ])
    try:
        book = load_workbook(WORKBOOK_PATH)
    except Exception:
        with pd.ExcelWriter(WORKBOOK_PATH, engine="openpyxl") as w:
            pd.DataFrame().to_excel(w, sheet_name="INIT", index=False)
        book = load_workbook(WORKBOOK_PATH)
    if "CLO_Table" in book.sheetnames:
        del book["CLO_Table"]
    with pd.ExcelWriter(WORKBOOK_PATH, engine="openpyxl", mode="a") as w:
        w._book = book
        df_empty.to_excel(w, sheet_name="CLO_Table", index=False)
    return redirect(url_for("index"))

@app.route("/download")
def download():
    df = read_clo_table()
    if df.empty: return "<p>No CLO table to download.</p>"
    out = BytesIO()
    with pd.ExcelWriter(out, engine="openpyxl") as w:
        df.to_excel(w, sheet_name="CLO_Table", index=False)
    out.seek(0)
    return send_file(out, as_attachment=True, download_name="CLO_Table.xlsx",
                     mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
def construct_clo_sentence(verb, content, sc_desc, condition, criterion, vbe):
    """
    Custom CLO Template aligned with MQA + VBE + Sustainability Competency (SC).

    Final CLO structure:
    [Verb] [Content]
    using anticipatory thinking
    by effectively performing tasks that involve analyzing task requirements,
    guided by ethics and professionalism.
    """

    # Fixed SC and VBE (MQA requirement)
    thinking = "anticipatory thinking"
    action   = "effectively performing tasks that involve analyzing task requirements"
    vbe_part = "guided by ethics and professionalism"

    # Build final CLO text
    clo = (
        f"{verb.capitalize()} {content} "
        f"using {thinking} "
        f"by {action}, "
        f"{vbe_part}."
    )

    return clo

def polish_condition(raw_condition, profile=None, bloom=None):
    """
    Refines 'Condition = under what context' into elegant, academic phrasing.
    Produces discipline-aware polished versions.
    """

    profile = (profile or "").lower()
    bloom   = (bloom or "").lower()
    cond    = (raw_condition or "").strip().lower()

    # Discipline-aware default contexts
    profile_contexts = {
        "":       "in discipline-relevant contexts",
        "health": "in clinical or health decision-making contexts",
        "sc":     "in computational or system-analysis contexts",
        "eng":    "in technical or engineering problem-solving contexts",
        "bus":    "in organisational or strategic decision-making contexts",
        "edu":    "in teaching, learning, or pedagogical analysis contexts",
        "socs":   "in social or behavioural evaluation contexts",
        "arts":   "in creative or cultural interpretation contexts"
    }
    default_context = profile_contexts.get(profile, "in professional contexts")

    # If Excel sheet already gives a specific condition
    if cond:
        # Soft rewrite to academic phrasing
        if cond.startswith(("when", "while", "during")):
            cond = f"in the context of {cond[4:].strip()}"
        elif cond.startswith("based on"):
            cond = f"when working with {cond[8:].strip()}"
        else:
            cond = f"in the context of {cond}"

    else:
        # No condition provided → generate Bloom-aligned condition
        bloom_context_map = {
            "remember":   "in foundational recall activities",
            "understand": "when interpreting essential concepts",
            "apply":      "in practical or real-world situations",
            "analyse":    "when examining complex information or cases",
            "evaluate":   "when making informed or evidence-based judgements",
            "create":     "in generating new ideas, strategies, or solutions"
        }
        cond = bloom_context_map.get(bloom, default_context)

    return cond


if __name__ == "__main__":
    app.run(debug=True)
